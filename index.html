<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenAI Real-time Audio Demo</title>
    <link rel="stylesheet" href="/static/styles.css">
</head>
<body>
    <div class="container">
        <h1>Friendly 日本語 (Japanese) Chatbot</h1>
        
        <div class="controls" style="text-align: center; margin-bottom: 2rem;">
            <button id="startButton">Start</button>
            <div id="status" class="status">Ready to start</div>
            <button id="stopButton" disabled>Stop</button>
        </div>

        <div class="transcript-container">
            <div id="transcript" class="transcript"></div>
        </div>

        <div class="bottom-controls">
            <button id="saveButton" class="secondary-button" disabled>Save Conversation</button>
            <button id="viewSavedButton" class="secondary-button">View Saved</button>
        </div>

        <div id="error" class="error"></div>
    </div>

    <!-- Add this modal structure -->
    <div id="savedConversationsModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Saved Conversations</h2>
            <div id="savedConversationsList"></div>
        </div>
    </div>

    <script>
        // this section is variables for the UI elements
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const transcriptDiv = document.getElementById('transcript');
        const statusDiv = document.getElementById('status');
        const errorDiv = document.getElementById('error');
        const saveButton = document.getElementById('saveButton');
        const viewSavedButton = document.getElementById('viewSavedButton');
        const modal = document.getElementById('savedConversationsModal');
        const closeBtn = document.querySelector('.close');
        const savedConversationsList = document.getElementById('savedConversationsList');

        let peerConnection = null;
        let audioStream = null;
        let dataChannel = null;

        let currentConversation = {
            messages: [],
            timestamp: null
        };

        // Function to display the transcribed user audio.
        function handleUserTranscript(transcribedText) {
            const p = document.createElement('p');
            p.innerHTML = `<strong>USER:</strong> ${transcribedText}`;
            transcriptDiv.appendChild(p);
            
            currentConversation.messages.push({
                role: 'user',
                text: transcribedText
            });
        }

        // Message handling functions
        function handleTranscript(message) {
            if (message.response?.output?.[0]?.content?.[0]?.transcript) {
                const text = message.response.output[0].content[0].transcript;
                const p = document.createElement('p');
                p.setAttribute('data-ai', 'true');
                p.innerHTML = `<strong>AI:</strong> `;
                transcriptDiv.appendChild(p);
                
                currentConversation.messages.push({
                    role: 'ai',
                    text: text
                });
                
                // Animate text character by character
                let index = 0;
                const interval = setInterval(() => {
                    if (index < text.length) {
                        p.innerHTML = `<strong>AI:</strong> ${text.substring(0, index + 1)}`;
                        index++;
                    } else {
                        clearInterval(interval);
                    }
                }, 30);
            }
        }

        async function handleWeatherFunction(output) {
            try {
                const args = JSON.parse(output.arguments);
                const location = args.location;
                
                const response = await fetch(`http://localhost:8888/weather/${encodeURIComponent(location)}`);
                const data = await response.json();
                
                // Send function output
                sendFunctionOutput(output.call_id, {
                    temperature: data.temperature,
                    unit: data.unit,
                    location: location
                });
                
                // Request new response
                sendResponseCreate();
            } catch (error) {
                showError('Error handling weather function: ' + error.message);
            }
        }

        function handleFunctionCall(output) {
            if (output?.type === "function_call" && 
                output?.name === "get_weather" && 
                output?.call_id) {
                console.log('Function call found:', output);
                handleWeatherFunction(output);
            }
        }

        function handleMessage(event) {
            try {
                const message = JSON.parse(event.data);
                console.log('Received message:', message);
                
                switch (message.type) {
                    // New case to display user transcript
                    case "user.transcript":
                        handleUserTranscript(message.transcript);
                        break;

                    case "response.done":
                        handleTranscript(message);
                        const output = message.response?.output?.[0];
                        if (output) handleFunctionCall(output);
                        break;

                    default:
                        console.log('Unhandled message type:', message.type);
                }
            } catch (error) {
                showError('Error processing message: ' + error.message);
            }
        }

        // WebRTC setup functions
        async function setupAudio() {
            const audioEl = document.createElement("audio");
            audioEl.autoplay = true;
            peerConnection.ontrack = e => audioEl.srcObject = e.streams[0];
            
            audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            peerConnection.addTrack(audioStream.getTracks()[0]);
        }

        function setupDataChannel() {
            dataChannel = peerConnection.createDataChannel("oai-events");
            dataChannel.onopen = onDataChannelOpen;
            dataChannel.addEventListener("message", handleMessage);
        }

        // Message sending functions
        function sendSessionUpdate() {
            const sessionUpdateEvent = {
                "type": "session.update",
                "session": {
                    "tools": [{
                        "type": "function",
                        "name": "get_weather",
                        "description": "Get the current weather. Works only for Earth",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "location": { "type": "string" }
                            },
                            "required": ["location"]
                        }
                    }],
                    "tool_choice": "auto"
                }
            };
            sendMessage(sessionUpdateEvent);
        }

        function sendInitialMessage() {
            const conversationMessage = {
                "type": "conversation.item.create",
                "previous_item_id": null,
                "item": {
                    "id": "msg_" + Date.now(),
                    "type": "message",
                    "role": "user",
                    "content": [{
                        "type": "input_text",
                        "text": "日本語でゆっくり、そしてフレンドリーなトーンで話してください。"
                    }]
                }
            };
            sendMessage(conversationMessage);
        }

        function sendFunctionOutput(callId, data) {
            const responseMessage = {
                "type": "conversation.item.create",
                "item": {
                    "type": "function_call_output",
                    "call_id": callId,
                    "output": JSON.stringify(data)
                }
            };
            sendMessage(responseMessage);
        }

        function sendResponseCreate() {
            sendMessage({ "type": "response.create" });
        }

        function sendMessage(message) {
            if (dataChannel?.readyState === "open") {
                dataChannel.send(JSON.stringify(message));
                console.log('Sent message:', message);
            }
        }

        function onDataChannelOpen() {
            sendSessionUpdate();
            sendInitialMessage();
        }

        // Main control functions
        async function init() {
            startButton.disabled = true;
            
            try {
                updateStatus('Initializing...');
                
                const tokenResponse = await fetch("http://localhost:8888/session");
                const data = await tokenResponse.json();
                const EPHEMERAL_KEY = data.client_secret.value;

                peerConnection = new RTCPeerConnection();
                await setupAudio();
                setupDataChannel();

                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                const baseUrl = "https://api.openai.com/v1/realtime";
                const model = "gpt-4o-realtime-preview-2024-12-17";
                const sdpResponse = await fetch(`${baseUrl}?model=${model}`, {
                    method: "POST",
                    body: offer.sdp,
                    headers: {
                        Authorization: `Bearer ${EPHEMERAL_KEY}`,
                        "Content-Type": "application/sdp"
                    },
                });

                const answer = {
                    type: "answer",
                    sdp: await sdpResponse.text(),
                };
                await peerConnection.setRemoteDescription(answer);

                updateStatus('Connected');
                stopButton.disabled = false;
                hideError();

            } catch (error) {
                startButton.disabled = false;
                stopButton.disabled = true;
                showError('Error: ' + error.message);
                console.error('Initialization error:', error);
                updateStatus('Failed to connect');
            }

            saveButton.disabled = false;
        }

        function stopRecording() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }
            startButton.disabled = false;
            stopButton.disabled = true;
            updateStatus('Ready to start');
        }

        // UI helper functions
        function updateStatus(message) {
            statusDiv.textContent = message;
        }

        function showError(message) {
            errorDiv.style.display = 'block';
            errorDiv.textContent = message;
        }

        function hideError() {
            errorDiv.style.display = 'none';
        }

        // Event listeners
        startButton.addEventListener('click', init);
        stopButton.addEventListener('click', stopRecording);
        document.addEventListener('DOMContentLoaded', () => updateStatus('Ready to start'));
        saveButton.addEventListener('click', saveCurrentConversation);
        viewSavedButton.addEventListener('click', () => {
            loadSavedConversations();
            modal.style.display = 'block';
        });
        closeBtn.addEventListener('click', () => {
            modal.style.display = 'none';
        });
        window.addEventListener('click', (event) => {
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        });

        // Add these functions for conversation management
        function saveCurrentConversation() {
            if (currentConversation.messages.length === 0) return;
            
            const conversations = JSON.parse(localStorage.getItem('conversations') || '[]');
            currentConversation.timestamp = new Date().toISOString();
            conversations.push(currentConversation);
            localStorage.setItem('conversations', JSON.stringify(conversations));
            
            showError('Conversation saved successfully!');
            setTimeout(hideError, 2000);
        }

        function deleteConversation(index, event) {
            event.stopPropagation(); // Prevent triggering the conversation loading
            
            if (confirm('Are you sure you want to delete this conversation?')) {
                const conversations = JSON.parse(localStorage.getItem('conversations') || '[]');
                conversations.splice(conversations.length - 1 - index, 1);
                localStorage.setItem('conversations', JSON.stringify(conversations));
                loadSavedConversations(); // Reload the list
            }
        }

        function loadSavedConversations() {
            const conversations = JSON.parse(localStorage.getItem('conversations') || '[]');
            savedConversationsList.innerHTML = '';
            
            conversations.reverse().forEach((conv, index) => {
                const div = document.createElement('div');
                div.className = 'saved-conversation-item';
                const date = new Date(conv.timestamp).toLocaleString();
                const preview = conv.messages[0]?.text || 'Empty conversation';
                
                div.innerHTML = `
                    <div class="conversation-content">
                        <strong>${date}</strong>
                        <div class="conversation-preview">${preview.substring(0, 100)}...</div>
                    </div>
                    <button class="delete-conversation" title="Delete conversation">🗑️</button>
                `;
                
                // Add click handler for loading conversation
                div.querySelector('.conversation-content').onclick = () => loadConversation(conversations.length - 1 - index);
                
                // Add click handler for delete button
                div.querySelector('.delete-conversation').onclick = (e) => deleteConversation(index, e);
                
                savedConversationsList.appendChild(div);
            });
        }

        function loadConversation(index) {
            const conversations = JSON.parse(localStorage.getItem('conversations') || '[]');
            const conversation = conversations[index];
            
            transcriptDiv.innerHTML = '';
            conversation.messages.forEach(msg => {
                const p = document.createElement('p');
                if (msg.role === 'ai') {
                    p.setAttribute('data-ai', 'true');
                }
                p.innerHTML = `<strong>${msg.role.toUpperCase()}:</strong> ${msg.text}`;
                transcriptDiv.appendChild(p);
            });
            
            currentConversation = {
                messages: [...conversation.messages],
                timestamp: conversation.timestamp
            };
            
            modal.style.display = 'none';
        }
    </script>
</body>
</html>
